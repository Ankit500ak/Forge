import { createClient } from '@supabase/supabase-js';
import { checkLevelUp, getLevelFromXp } from '../utils/level.js';
import { generateAndStoreTask, getRecentTasks } from '../mlTaskGenerator.js';
import { generateSimpleTasks, generateSimpleTaskForUser } from '../simpleTaskGenerator.js';

const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_SERVICE_ROLE_KEY
);

// Generate task using ML model
export const generateMLTaskForUser = async (req, res) => {
  const userId = req.userId;

  try {
    console.log(`[ML] Generating task for user ${userId}`);

    if (!userId) {
      return res.status(401).json({ message: 'User not authenticated' });
    }

    // Use mlTaskGenerator to generate and store task
    const createdTask = await generateAndStoreTask(userId);

    console.log(`[ML] âœ… Task generated and saved:`, createdTask.id);

    res.status(201).json({
      message: 'ML task generated successfully',
      task: {
        id: createdTask.id,
        title: createdTask.title,
        description: createdTask.description,
        category: createdTask.category,
        difficulty: createdTask.difficulty,
        xp_reward: createdTask.xp_reward,
        duration: createdTask.duration,
        stat_rewards: createdTask.stat_rewards,
        scheduled_date: createdTask.scheduled_date
      }
    });

  } catch (err) {
    console.error('[ML] Error generating task:', err.message);
    res.status(500).json({ 
      message: 'Failed to generate ML task', 
      error: err.message 
    });
  }
};

// Generate multiple ML tasks
export const generateMLTasksBatch = async (req, res) => {
  const userId = req.userId;
  const { count = 4 } = req.body;

  try {
    console.log(`[ML] Generating ${count} tasks for user ${userId}`);

    if (!userId) {
      return res.status(401).json({ message: 'User not authenticated' });
    }

    if (count < 1 || count > 10) {
      return res.status(400).json({ message: 'Count must be between 1 and 10' });
    }

    const generatedTasks = [];

    // Generate multiple tasks using mlTaskGenerator
    for (let i = 0; i < count; i++) {
      try {
        console.log(`[ML] Generating task ${i + 1}/${count}...`);
        const task = await generateAndStoreTask(userId);
        
        generatedTasks.push({
          id: task.id,
          title: task.title,
          description: task.description,
          category: task.category,
          difficulty: task.difficulty,
          xp_reward: task.xp_reward,
          duration: task.duration,
          stat_rewards: task.stat_rewards
        });
      } catch (taskErr) {
        console.error(`[ML] Error generating task ${i + 1}:`, taskErr.message);
        // Continue generating other tasks
      }
    }

    console.log(`[ML] âœ… Generated ${generatedTasks.length} tasks`);

    res.status(201).json({
      message: `${generatedTasks.length} tasks generated successfully`,
      tasks: generatedTasks,
      count: generatedTasks.length
    });

  } catch (err) {
    console.error('[ML] Error generating task batch:', err.message);
    res.status(500).json({ 
      message: 'Failed to generate ML tasks', 
      error: err.message 
    });
  }
};

// Get all tasks for today
export const getTodayTasks = async (req, res) => {
  try {
    const userId = req.userId;
    console.log(`[getTodayTasks] Fetching tasks for user: ${userId}`);

    if (!userId) {
      return res.status(401).json({ message: 'User not authenticated' });
    }
    
    // Check if user has ANY tasks
    const { count: taskCount, error: countError } = await supabase
      .from('tasks')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', userId);

    if (countError) {
      console.error('[getTodayTasks] Error counting tasks:', countError);
      return res.status(500).json({ 
        message: 'Failed to check user tasks', 
        error: countError.message 
      });
    }
    
    const countNum = taskCount || 0;
    console.log(`[getTodayTasks] Task count: ${countNum}`);
    
    let autoGenerated = false;
    
    // If user has no tasks, auto-generate 5 tasks
    if (countNum === 0) {
      console.log(`[getTodayTasks] ðŸš€ ENTERING AUTO-GENERATION BLOCK...`);
      
      try {
        // Get user's fitness level
        const { data: userData, error: userError } = await supabase
          .from('users')
          .select('id, fitness_profiles(fitness_level)')
          .eq('id', userId)
          .single();

        if (userError) {
          console.error('[getTodayTasks] Error fetching user data:', userError);
        }
        
        const fitnessLevel = userData?.fitness_profiles?.fitness_level || 'beginner';
        console.log(`[getTodayTasks] Fitness level: ${fitnessLevel}`);
        
        // Generate 5 tasks using simple generator
        const generatedTasks = await generateSimpleTasks(userId, fitnessLevel, 5);
        console.log(`[getTodayTasks] âœ… Generated ${generatedTasks.length} tasks`);
        autoGenerated = true;
      } catch (genErr) {
        console.error(`[getTodayTasks] âŒ Error auto-generating tasks:`, genErr);
        // Don't block if generation fails - user will get empty list
      }
    }
    
    // Now fetch today's tasks (including newly generated ones)
    console.log(`[getTodayTasks] Fetching today's tasks...`);
    
    const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD format
    
    const { data: tasks, error: tasksError } = await supabase
      .from('tasks')
      .select(`
        id, 
        title, 
        description, 
        category, 
        xp_reward, 
        completed, 
        completed_at,
        scheduled_date,
        difficulty,
        duration,
        stat_rewards
      `)
      .eq('user_id', userId)
      .eq('scheduled_date', today)
      .order('completed', { ascending: true })
      .order('created_at', { ascending: true });

    if (tasksError) {
      console.error('[getTodayTasks] Error fetching tasks:', tasksError);
      return res.status(500).json({ 
        message: 'Failed to fetch tasks', 
        error: tasksError.message 
      });
    }

    console.log(`[getTodayTasks] Found ${tasks?.length || 0} tasks for today`);
    
    res.json({
      message: 'Today tasks retrieved',
      tasks: tasks || [],
      total: tasks?.length || 0,
      completedCount: tasks?.filter(t => t.completed).length || 0,
      autoGenerated: autoGenerated,
    });
  } catch (err) {
    console.error('[Tasks] Error fetching today tasks:', err);
    res.status(500).json({ 
      message: 'Failed to fetch tasks', 
      error: err.message 
    });
  }
};

// Get all tasks for a user
export const getUserTasks = async (req, res) => {
  try {
    const userId = req.userId;
    const { date } = req.query; // optional date filter (YYYY-MM-DD)

    if (!userId) {
      return res.status(401).json({ message: 'User not authenticated' });
    }

    let query = supabase
      .from('tasks')
      .select('*')
      .eq('user_id', userId);

    if (date) {
      query = query.eq('scheduled_date', date);
    }

    const { data: tasks, error } = await query
      .order('scheduled_date', { ascending: false })
      .order('created_at', { ascending: false });

    if (error) {
      console.error('[Tasks] Error fetching user tasks:', error);
      return res.status(500).json({ 
        message: 'Failed to fetch tasks', 
        error: error.message 
      });
    }

    res.json({
      message: 'User tasks retrieved',
      tasks: tasks || [],
      total: tasks?.length || 0,
      autoGenerated: false,
    });
  } catch (err) {
    console.error('[Tasks] Error fetching user tasks:', err);
    res.status(500).json({ 
      message: 'Failed to fetch tasks', 
      error: err.message 
    });
  }
};

// Complete a task and add XP
export const completeTask = async (req, res) => {
  const userId = req.userId;
  const { taskId } = req.body;

  try {
    console.log(`[Tasks] Completing task ${taskId} for user ${userId}`);

    if (!taskId) {
      return res.status(400).json({ message: 'Task ID is required' });
    }

    if (!userId) {
      return res.status(401).json({ message: 'User not authenticated' });
    }

    // Get task
    const { data: task, error: taskError } = await supabase
      .from('tasks')
      .select('*')
      .eq('id', taskId)
      .eq('user_id', userId)
      .single();

    if (taskError) {
      if (taskError.code === 'PGRST116') {
        console.log(`[Tasks] Task not found: ${taskId}`);
        return res.status(404).json({ message: 'Task not found' });
      }
      console.error('[Tasks] Error fetching task:', taskError);
      return res.status(500).json({ 
        message: 'Failed to fetch task', 
        error: taskError.message 
      });
    }

    console.log(`[Tasks] Found task: ${task.title}, XP reward: ${task.xp_reward}`);

    if (task.completed) {
      return res.status(400).json({ message: 'Task already completed' });
    }

    const xpReward = parseInt(task.xp_reward) || 0;

    // ðŸ‘‘ GET STAT REWARDS from task
    let statRewards = {};
    if (task.stat_rewards) {
      try {
        // Handle different formats: string, object, or JSON string
        if (typeof task.stat_rewards === 'string') {
          // Check if it's a valid JSON string
          if (task.stat_rewards.startsWith('{') || task.stat_rewards.startsWith('[')) {
            statRewards = JSON.parse(task.stat_rewards);
          } else {
            // It's not JSON, skip it
            console.warn(`[Tasks] Warning: stat_rewards is not valid JSON: "${task.stat_rewards}"`);
            statRewards = {};
          }
        } else if (typeof task.stat_rewards === 'object') {
          // Already an object, use as-is
          statRewards = task.stat_rewards;
        }
      } catch (parseErr) {
        console.warn(`[Tasks] Warning: Could not parse stat_rewards for task ${task.id}:`, parseErr.message);
        statRewards = {};
      }
    }
    console.log(`[Tasks] ðŸ“Š Stat rewards for "${task.title}":`, statRewards);

    // Mark task as completed
    const { error: completeError } = await supabase
      .from('tasks')
      .update({ 
        completed: true, 
        completed_at: new Date().toISOString() 
      })
      .eq('id', taskId);

    if (completeError) {
      console.error('[Tasks] Error marking task as completed:', completeError);
      return res.status(500).json({ 
        message: 'Failed to complete task', 
        error: completeError.message 
      });
    }

    // Ensure user_progression and user_stats rows exist
    try {
      // Check if progression row exists
      const { data: progCheck, error: progCheckError } = await supabase
        .from('user_progression')
        .select('*')
        .eq('user_id', userId)
        .maybeSingle();

      if (progCheckError) {
        console.error('[Tasks] Error checking progression:', progCheckError);
        throw new Error(`Failed to check user progression: ${progCheckError.message}`);
      }

      if (!progCheck) {
        console.log(`[Tasks] Creating missing progression row for user ${userId}`);
        const { error: progInsertError } = await supabase
          .from('user_progression')
          .insert({
            user_id: userId,
            level: 1,
            stat_points: 0,
            xp_today: 0,
            rank: 'F',
            total_xp: 0,
            weekly_xp: 0,
            monthly_xp: 0,
            experience_points: 0,
            next_level_percent: 0,
            joined_date: new Date().toISOString(),
            last_active: new Date().toISOString(),
            created_at: new Date().toISOString()
          });

        if (progInsertError) {
          console.error('[Tasks] Error creating progression:', progInsertError);
          throw new Error(`Failed to create user progression: ${progInsertError.message}`);
        }
      }

      // Check if stats row exists
      const { data: statsCheck, error: statsCheckError } = await supabase
        .from('user_stats')
        .select('*')
        .eq('user_id', userId)
        .maybeSingle();

      if (statsCheckError) {
        console.error('[Tasks] Error checking stats:', statsCheckError);
        throw new Error(`Failed to check user stats: ${statsCheckError.message}`);
      }

      if (!statsCheck) {
        console.log(`[Tasks] Creating missing stats row for user ${userId}`);
        const { error: statsInsertError } = await supabase
          .from('user_stats')
          .insert({
            user_id: userId,
            user_id_ref: userId,
            bench_press: 0,
            deadlift: 0,
            squat: 0,
            total_lifted: 0,
            strength_goal: 0,
            distance_run_km: 0,
            calories_burned: 0,
            cardio_sessions: 0,
            longest_run_km: 0,
            strength: 0,
            speed: 0,
            endurance: 0,
            agility: 0,
            power: 0,
            recovery: 0,
            reflex_time: 0,
            flexibility: 0,
            bmi: 0,
            resting_heart_rate: 0,
            sleep_quality: 0,
            stress_level: 0,
            health: 10,
            base_stats: 10,
            experience_points: 0,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString()
          });

        if (statsInsertError) {
          console.error('[Tasks] Error creating stats:', statsInsertError);
          throw new Error(`Failed to create user stats: ${statsInsertError.message}`);
        }
      }
    } catch (initErr) {
      console.error(`[Tasks] Error initializing user tables:`, initErr.message);
      return res.status(500).json({ 
        message: 'Failed to initialize user data', 
        error: initErr.message 
      });
    }

    // Get current progression values
    const { data: currentProg, error: currentProgError } = await supabase
      .from('user_progression')
      .select('xp_today, total_xp, weekly_xp, monthly_xp')
      .eq('user_id', userId)
      .single();

    if (currentProgError) {
      console.error('[Tasks] Error fetching current progression:', currentProgError);
      return res.status(500).json({ 
        message: 'Failed to fetch user progression', 
        error: currentProgError.message 
      });
    }

    // Add XP to user progression
    try {
      const { error: progUpdateError } = await supabase
        .from('user_progression')
        .update({
          xp_today: (currentProg.xp_today || 0) + xpReward,
          total_xp: (currentProg.total_xp || 0) + xpReward,
          weekly_xp: (currentProg.weekly_xp || 0) + xpReward,
          monthly_xp: (currentProg.monthly_xp || 0) + xpReward,
          updated_at: new Date().toISOString()
        })
        .eq('user_id', userId);

      if (progUpdateError) {
        console.error('[Tasks] Error updating progression:', progUpdateError);
        throw new Error(`Failed to update user progression: ${progUpdateError.message}`);
      }
    } catch (progErr) {
      console.error(`[Tasks] Error updating progression:`, progErr.message);
      return res.status(500).json({ 
        message: 'Failed to update progression', 
        error: progErr.message 
      });
    }

    // ðŸ‘‘ UPDATE USER STATS with stat rewards from task
    try {
      // Whitelist of valid stat columns (6-stat system)
      const validStats = ['strength', 'speed', 'endurance', 'agility', 'power', 'recovery'];
      
      const appliedStats = {};
      const updateData = { updated_at: new Date().toISOString() };

      // Get current stat values
      const { data: currentStats, error: currentStatsError } = await supabase
        .from('user_stats')
        .select(validStats.join(', '))
        .eq('user_id', userId)
        .single();

      if (currentStatsError) {
        console.error('[Tasks] Error fetching current stats:', currentStatsError);
        throw new Error(`Failed to fetch current stats: ${currentStatsError.message}`);
      }

      // Build update object based on stat_rewards (with validation)
      for (const [stat, value] of Object.entries(statRewards)) {
        // Validate column name
        if (!validStats.includes(stat)) {
          console.warn(`[Tasks] Skipping invalid stat column: ${stat}`);
          continue;
        }

        const currentValue = parseInt(currentStats[stat]) || 0;
        const rewardValue = parseInt(value) || 0;

        if (rewardValue !== 0) {
          // Ensure stats don't go below 0
          const newValue = Math.max(0, currentValue + rewardValue);
          updateData[stat] = newValue;
          appliedStats[stat] = rewardValue;
        }
      }

      // Only update if there are stat changes
      if (Object.keys(appliedStats).length > 0) {
        const { error: statsUpdateError } = await supabase
          .from('user_stats')
          .update(updateData)
          .eq('user_id', userId);

        if (statsUpdateError) {
          console.error('[Tasks] Error updating stats:', statsUpdateError);
          throw new Error(`Failed to update stats: ${statsUpdateError.message}`);
        }

        console.log(`[Tasks] âœ… Stat rewards applied to user: ${JSON.stringify(appliedStats)}`);
      }
    } catch (statErr) {
      console.error(`[Tasks] Error updating stats:`, statErr.message);
      // Don't fail the task completion, just log the error
    }

    // Get updated progression
    const { data: updated, error: updatedError } = await supabase
      .from('user_progression')
      .select('*')
      .eq('user_id', userId)
      .single();

    if (updatedError) {
      console.error('[Tasks] Error fetching updated progression:', updatedError);
      // Don't fail, just return the values we know
    }

    console.log(`[Tasks] Task completed successfully! Added ${xpReward} XP`);

    res.json({
      message: 'Task completed successfully',
      task: {
        id: task.id,
        title: task.title,
        xpGain: xpReward,
        category: task.category
      },
      progression: {
        xp_today: updated?.xp_today || (currentProg.xp_today + xpReward),
        total_xp: updated?.total_xp || (currentProg.total_xp + xpReward),
        weekly_xp: updated?.weekly_xp || (currentProg.weekly_xp + xpReward),
        monthly_xp: updated?.monthly_xp || (currentProg.monthly_xp + xpReward),
      }
    });
  } catch (err) {
    console.error('[Tasks] Error completing task:', err.message);
    console.error('[Tasks] Stack:', err.stack);
    res.status(500).json({ 
      message: 'Failed to complete task', 
      error: err.message 
    });
  }
};

// Create a new task (admin or user can create for themselves)
export const createTask = async (req, res) => {
  try {
    const userId = req.userId;
    const { title, description, category, xpReward, scheduledDate } = req.body;

    if (!userId) {
      return res.status(401).json({ message: 'User not authenticated' });
    }

    if (!title || !category || !xpReward || !scheduledDate) {
      return res.status(400).json({ 
        message: 'Title, category, xpReward, and scheduledDate are required' 
      });
    }

    const { data: task, error } = await supabase
      .from('tasks')
      .insert({
        user_id: userId,
        title,
        description: description || null,
        category,
        xp_reward: xpReward,
        scheduled_date: scheduledDate
      })
      .select()
      .single();

    if (error) {
      console.error('[Tasks] Error creating task:', error);
      return res.status(500).json({ 
        message: 'Failed to create task', 
        error: error.message 
      });
    }

    res.status(201).json({
      message: 'Task created successfully',
      task: task,
    });
  } catch (err) {
    console.error('[Tasks] Error creating task:', err);
    res.status(500).json({ 
      message: 'Failed to create task', 
      error: err.message 
    });
  }
};

// Delete a task
export const deleteTask = async (req, res) => {
  try {
    const userId = req.userId;
    const { taskId } = req.params;

    if (!userId) {
      return res.status(401).json({ message: 'User not authenticated' });
    }

    if (!taskId) {
      return res.status(400).json({ message: 'Task ID is required' });
    }

    const { data: task, error } = await supabase
      .from('tasks')
      .delete()
      .eq('id', taskId)
      .eq('user_id', userId)
      .select()
      .single();

    if (error) {
      if (error.code === 'PGRST116') {
        return res.status(404).json({ message: 'Task not found' });
      }
      console.error('[Tasks] Error deleting task:', error);
      return res.status(500).json({ 
        message: 'Failed to delete task', 
        error: error.message 
      });
    }

    res.json({
      message: 'Task deleted successfully',
      task: task,
    });
  } catch (err) {
    console.error('[Tasks] Error deleting task:', err);
    res.status(500).json({ 
      message: 'Failed to delete task', 
      error: err.message 
    });
  }
};