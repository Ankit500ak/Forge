import { Pool } from 'pg';
import { checkLevelUp, getLevelFromXp } from '../utils/level.js';
import { generateAndStoreTask, getRecentTasks } from '../mlTaskGenerator.js';
import { generateSimpleTasks, generateSimpleTaskForUser } from '../simpleTaskGenerator.js';

// Parse connection string to avoid system environment variable interference
const parseConnectionString = () => {
  if (!process.env.POSTGRES_URL) {
    throw new Error('POSTGRES_URL environment variable is required.');
  }
  return { connectionString: process.env.POSTGRES_URL, connectionTimeoutMillis: 5000 };
};

const pool = new Pool(parseConnectionString());

// Generate task using ML model
export const generateMLTaskForUser = async (req, res) => {
  const userId = req.userId;

  try {
    console.log(`[ML] Generating task for user ${userId}`);

    if (!userId) {
      return res.status(401).json({ message: 'User not authenticated' });
    }

    // Use mlTaskGenerator to generate and store task
    const createdTask = await generateAndStoreTask(userId);

    console.log(`[ML] âœ… Task generated and saved:`, createdTask.id);

    res.status(201).json({
      message: 'ML task generated successfully',
      task: {
        id: createdTask.id,
        title: createdTask.title,
        description: createdTask.description,
        category: createdTask.category,
        difficulty: createdTask.difficulty,
        xp_reward: createdTask.xp_reward,
        duration: createdTask.duration,
        stat_rewards: createdTask.stat_rewards,
        scheduled_date: createdTask.scheduled_date
      }
    });

  } catch (err) {
    console.error('[ML] Error generating task:', err.message);
    res.status(500).json({ 
      message: 'Failed to generate ML task', 
      error: err.message 
    });
  }
};

// Generate multiple ML tasks
export const generateMLTasksBatch = async (req, res) => {
  const userId = req.userId;
  const { count = 4 } = req.body;

  try {
    console.log(`[ML] Generating ${count} tasks for user ${userId}`);

    if (!userId) {
      return res.status(401).json({ message: 'User not authenticated' });
    }

    if (count < 1 || count > 10) {
      return res.status(400).json({ message: 'Count must be between 1 and 10' });
    }

    const generatedTasks = [];

    // Generate multiple tasks using mlTaskGenerator
    for (let i = 0; i < count; i++) {
      try {
        console.log(`[ML] Generating task ${i + 1}/${count}...`);
        const task = await generateAndStoreTask(userId);
        
        generatedTasks.push({
          id: task.id,
          title: task.title,
          description: task.description,
          category: task.category,
          difficulty: task.difficulty,
          xp_reward: task.xp_reward,
          duration: task.duration,
          stat_rewards: task.stat_rewards
        });
      } catch (taskErr) {
        console.error(`[ML] Error generating task ${i + 1}:`, taskErr.message);
        // Continue generating other tasks
      }
    }

    console.log(`[ML] âœ… Generated ${generatedTasks.length} tasks`);

    res.status(201).json({
      message: `${generatedTasks.length} tasks generated successfully`,
      tasks: generatedTasks,
      count: generatedTasks.length
    });

  } catch (err) {
    console.error('[ML] Error generating task batch:', err.message);
    res.status(500).json({ 
      message: 'Failed to generate ML tasks', 
      error: err.message 
    });
  }
};

// Get all tasks for today
export const getTodayTasks = async (req, res) => {
  try {
    const userId = req.userId;
    console.log(`[getTodayTasks] Fetching tasks for user: ${userId}`);
    
    // Check if user has ANY tasks
    const userTasksCheck = await pool.query(
      `SELECT COUNT(*) as count FROM tasks WHERE user_id = $1`,
      [userId]
    );
    
    const countValue = userTasksCheck.rows[0].count;
    const countNum = parseInt(countValue);
    console.log(`[getTodayTasks] Task count raw: ${countValue}, type: ${typeof countValue}, parsed: ${countNum}`);
    
    let autoGenerated = false;
    
    // If user has no tasks, auto-generate 5 tasks
    if (countNum === 0 || countValue === 0) {
      console.log(`[getTodayTasks] ðŸš€ ENTERING AUTO-GENERATION BLOCK...`);
      
      try {
        // Get user's fitness level
        const userResult = await pool.query(
          `SELECT fp.fitness_level FROM users u
           LEFT JOIN fitness_profiles fp ON u.id = fp.user_id
           WHERE u.id = $1`,
          [userId]
        );
        
        const fitnessLevel = userResult.rows[0]?.fitness_level || 'beginner';
        console.log(`[getTodayTasks] Fitness level: ${fitnessLevel}`);
        
        // Generate 5 tasks using simple generator
        const generatedTasks = await generateSimpleTasks(userId, fitnessLevel, 5);
        console.log(`[getTodayTasks] âœ… Generated ${generatedTasks.length} tasks`);
        autoGenerated = true;
      } catch (genErr) {
        console.error(`[getTodayTasks] âŒ Error auto-generating tasks:`, genErr);
        // Don't block if generation fails - user will get empty list
      }
    }
    
    // Now fetch today's tasks (including newly generated ones)
    console.log(`[getTodayTasks] Fetching today's tasks...`);
    const { rows } = await pool.query(
      `SELECT 
        id, 
        title, 
        description, 
        category, 
        xp_reward, 
        completed, 
        completed_at,
        scheduled_date,
        difficulty,
        duration,
        stat_rewards
      FROM tasks 
      WHERE user_id = $1 AND scheduled_date = CURRENT_DATE
      ORDER BY completed ASC, created_at ASC`,
      [userId]
    );

    console.log(`[getTodayTasks] Found ${rows.length} tasks for today`);
    
    res.json({
      message: 'Today tasks retrieved',
      tasks: rows,
      total: rows.length,
      completedCount: rows.filter(t => t.completed).length,
      autoGenerated: autoGenerated,
    });
  } catch (err) {
    console.error('[Tasks] Error fetching today tasks:', err);
    res.status(500).json({ message: 'Failed to fetch tasks', error: err.message });
  }
};

// Get all tasks for a user
export const getUserTasks = async (req, res) => {
  try {
    const userId = req.userId;
    const { date } = req.query; // optional date filter (YYYY-MM-DD)

    let query = `SELECT * FROM tasks WHERE user_id = $1`;
    const params = [userId];

    if (date) {
      query += ` AND scheduled_date = $2`;
      params.push(date);
    }

    query += ` ORDER BY scheduled_date DESC, created_at DESC`;

    const { rows } = await pool.query(query, params);

    res.json({
      message: 'User tasks retrieved',
      tasks: rows,
      total: rows.length,
      autoGenerated: false,
    });
  } catch (err) {
    console.error('[Tasks] Error fetching user tasks:', err);
    res.status(500).json({ message: 'Failed to fetch tasks', error: err.message });
  }
};

// Complete a task and add XP
export const completeTask = async (req, res) => {
  const userId = req.userId;
  const { taskId } = req.body;

  try {
    console.log(`[Tasks] Completing task ${taskId} for user ${userId}`);

    if (!taskId) {
      return res.status(400).json({ message: 'Task ID is required' });
    }

    if (!userId) {
      return res.status(401).json({ message: 'User not authenticated' });
    }

    // Get task
    const taskResult = await pool.query(
      'SELECT * FROM tasks WHERE id = $1 AND user_id = $2',
      [taskId, userId]
    );

    if (taskResult.rows.length === 0) {
      console.log(`[Tasks] Task not found: ${taskId}`);
      return res.status(404).json({ message: 'Task not found' });
    }

    const task = taskResult.rows[0];
    console.log(`[Tasks] Found task: ${task.title}, XP reward: ${task.xp_reward}`);

    if (task.completed) {
      return res.status(400).json({ message: 'Task already completed' });
    }

    const xpReward = parseInt(task.xp_reward) || 0;

    // ðŸ‘‘ GET STAT REWARDS from task
    let statRewards = {};
    if (task.stat_rewards) {
      try {
        // Handle different formats: string, object, or JSON string
        if (typeof task.stat_rewards === 'string') {
          // Check if it's a valid JSON string
          if (task.stat_rewards.startsWith('{') || task.stat_rewards.startsWith('[')) {
            statRewards = JSON.parse(task.stat_rewards);
          } else {
            // It's not JSON, skip it
            console.warn(`[Tasks] Warning: stat_rewards is not valid JSON: "${task.stat_rewards}"`);
            statRewards = {};
          }
        } else if (typeof task.stat_rewards === 'object') {
          // Already an object, use as-is
          statRewards = task.stat_rewards;
        }
      } catch (parseErr) {
        console.warn(`[Tasks] Warning: Could not parse stat_rewards for task ${task.id}:`, parseErr.message);
        statRewards = {};
      }
    }
    console.log(`[Tasks] ðŸ“Š Stat rewards for "${task.title}":`, statRewards);

    // Mark task as completed
    await pool.query(
      'UPDATE tasks SET completed = true, completed_at = NOW() WHERE id = $1',
      [taskId]
    );

    // Ensure user_progression and user_stats rows exist
    try {
      // Check if progression row exists
      const progCheck = await pool.query(
        'SELECT * FROM user_progression WHERE user_id = $1',
        [userId]
      );

      if (progCheck.rows.length === 0) {
        console.log(`[Tasks] Creating missing progression row for user ${userId}`);
        await pool.query(
          `INSERT INTO user_progression 
            (user_id, level, stat_points, xp_today, rank, total_xp, weekly_xp, monthly_xp, experience_points, next_level_percent, joined_date, last_active, created_at)
           VALUES ($1, 1, 0, 0, 'F', 0, 0, 0, 0, 0, NOW(), NOW(), NOW())`,
          [userId]
        );
      }

      // Check if stats row exists
      const statsCheck = await pool.query(
        'SELECT * FROM user_stats WHERE user_id = $1',
        [userId]
      );

      if (statsCheck.rows.length === 0) {
        console.log(`[Tasks] Creating missing stats row for user ${userId}`);
        await pool.query(
          `INSERT INTO user_stats 
            (user_id, user_id_ref, bench_press, deadlift, squat, total_lifted, strength_goal, distance_run_km, calories_burned, cardio_sessions, longest_run_km, speed, reflex_time, flexibility, bmi, resting_heart_rate, sleep_quality, stress_level, health, base_stats, experience_points, created_at, updated_at)
           VALUES ($1, $1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 10, 0, NOW(), NOW())`,
          [userId]
        );
      }
    } catch (initErr) {
      console.error(`[Tasks] Error initializing user tables:`, initErr.message);
      return res.status(500).json({ message: 'Failed to initialize user data', error: initErr.message });
    }

    // Add XP to user progression - with error handling for missing table/row
    try {
      await pool.query(
        `UPDATE user_progression 
         SET xp_today = COALESCE(xp_today, 0) + $1,
             total_xp = COALESCE(total_xp, 0) + $1,
             weekly_xp = COALESCE(weekly_xp, 0) + $1,
             monthly_xp = COALESCE(monthly_xp, 0) + $1,
             updated_at = NOW()
         WHERE user_id = $2`,
        [xpReward, userId]
      );
    } catch (progErr) {
      console.error(`[Tasks] Error updating progression:`, progErr.message);
      throw new Error(`Failed to update user progression: ${progErr.message}`);
    }

    // ðŸ‘‘ UPDATE USER STATS with stat rewards from task
    try {
      // Whitelist of valid stat columns (6-stat system)
      const validStats = ['strength', 'speed', 'endurance', 'agility', 'power', 'recovery'];
      
      let updateQuery = 'UPDATE user_stats SET ';
      const params = [];
      let paramIndex = 1;
      const updates = [];
      const appliedStats = {};

      // Build dynamic UPDATE statement based on stat_rewards (with validation)
      for (const [stat, value] of Object.entries(statRewards)) {
        // Validate column name
        if (!validStats.includes(stat)) {
          console.warn(`[Tasks] Skipping invalid stat column: ${stat}`);
          continue;
        }

        if (value > 0) {
          updates.push(`${stat} = COALESCE(${stat}, 0) + $${paramIndex}`);
          params.push(value);
          appliedStats[stat] = value;
          paramIndex++;
        } else if (value < 0) {
          updates.push(`${stat} = GREATEST(0, COALESCE(${stat}, 0) + $${paramIndex})`);
          params.push(value);
          appliedStats[stat] = value;
          paramIndex++;
        }
      }

      // Add updated_at
      updates.push(`updated_at = NOW()`);

      if (updates.length > 1) {
        updateQuery += updates.join(', ') + ` WHERE user_id = $${paramIndex}`;
        params.push(userId);

        const updateResult = await pool.query(updateQuery, params);
        console.log(`[Tasks] âœ… Stat rewards applied to user: ${JSON.stringify(appliedStats)} (rows affected: ${updateResult.rowCount})`);
      }
    } catch (statErr) {
      console.error(`[Tasks] Error updating stats:`, statErr.message);
      // Don't fail the task completion, just log the error
    }

    // Get updated progression
    const progResult = await pool.query(
      'SELECT * FROM user_progression WHERE user_id = $1',
      [userId]
    );

    const updated = progResult.rows[0];

    console.log(`[Tasks] Task completed successfully! Added ${xpReward} XP`);

    res.json({
      message: 'Task completed successfully',
      task: {
        id: task.id,
        title: task.title,
        xpGain: xpReward,
        category: task.category
      },
      progression: {
        xp_today: updated?.xp_today || 0,
        total_xp: updated?.total_xp || 0,
        weekly_xp: updated?.weekly_xp || 0,
        monthly_xp: updated?.monthly_xp || 0,
      }
    });
  } catch (err) {
    console.error('[Tasks] Error completing task:', err.message);
    console.error('[Tasks] Stack:', err.stack);
    res.status(500).json({ 
      message: 'Failed to complete task', 
      error: err.message 
    });
  }
};

// Create a new task (admin or user can create for themselves)
export const createTask = async (req, res) => {
  try {
    const userId = req.userId;
    const { title, description, category, xpReward, scheduledDate } = req.body;

    if (!title || !category || !xpReward || !scheduledDate) {
      return res.status(400).json({ 
        message: 'Title, category, xpReward, and scheduledDate are required' 
      });
    }

    const { rows } = await pool.query(
      `INSERT INTO tasks (user_id, title, description, category, xp_reward, scheduled_date)
       VALUES ($1, $2, $3, $4, $5, $6)
       RETURNING *`,
      [userId, title, description || null, category, xpReward, scheduledDate]
    );

    res.status(201).json({
      message: 'Task created successfully',
      task: rows[0],
    });
  } catch (err) {
    console.error('[Tasks] Error creating task:', err);
    res.status(500).json({ message: 'Failed to create task', error: err.message });
  }
};

// Delete a task
export const deleteTask = async (req, res) => {
  try {
    const userId = req.userId;
    const { taskId } = req.params;

    const { rows } = await pool.query(
      'DELETE FROM tasks WHERE id = $1 AND user_id = $2 RETURNING *',
      [taskId, userId]
    );

    if (!rows[0]) {
      return res.status(404).json({ message: 'Task not found' });
    }

    res.json({
      message: 'Task deleted successfully',
      task: rows[0],
    });
  } catch (err) {
    console.error('[Tasks] Error deleting task:', err);
    res.status(500).json({ message: 'Failed to delete task', error: err.message });
  }
};
